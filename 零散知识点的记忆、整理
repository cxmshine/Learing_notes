1. 简单说说Java集合类 ? 
答: Java集合类位于java.util包下.一共有3种类型,分别是:set(集)、list(列表)、map（映射）.
    集合接口分为Collection和Map,其中list和set实现的是Collection接口,map实现的是Map接口 .
    
2.数据库中事务的四大特性ACID是指? 事务的隔离级别?
答: A : Atomicity 原子性 --- 事务包含的所有操作要么全部成功,要么全部失败回滚;
    C : Consistence 一致性 --- 一个事务执行之前和执行之后都必须处于一致性状态;
    I : Isolation  隔离性  ---  隔离性是当多个用户并发访问数据库时,比如操作同一张表时,数据库为每一个用户开启的事务,不能被其他事务的操作所干扰,多个并发事务之间要相互隔离;
    D : Durability 持久性  ---  持久性是指一个事务一旦被提交了,那么对数据库中的数据的改变就是永久性的,即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作. .
    
    在介绍数据库提供的各种隔离级别之前,我们先看看如果不考虑事务的隔离性,会发生的几种问题：
    1. 脏读 ; 2. 不可重复读 ; 3. 虚读(幻读)
    
    MySQL数据库为我们提供的四种隔离级别：
　　1)Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。
　　2)Repeatable read (可重复读)：可避免脏读、不可重复读的发生。
　　3)Read committed (读已提交)：可避免脏读的发生。
　　4)Read uncommitted (读未提交)：最低级别，任何情况都无法保证。
  
  注:以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。
    像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。
    在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。
　　在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)；
    而在Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别。
    
3.数据库表的范式?
答: 这里只讲1NF、2NF、3NF . 在满足1NF的基础上才能满足2NF,在满足2NF的基础上才能满足3NF.
    1NF : 数据库中的表的列具有原子性,不允许再分.例如salary这一列不可再分为 基本月薪与奖金 ;
    2NF : 表中的记录是唯一的,通常我们设计一个主键来实现;
    3NF : 表中不要有冗余数据,即:表中的信息,若能被推导出来,就不应该单独设计一个字段来存放,通常我们设计外键来实现.
    
4.数据库存储引擎?
答:在开发中,我们经常使用的存储引擎  myisam/innodb/memory.
MyISAM存储引擎
    如果表对事务要求不高，同时是以查询和添加为主的，我们考虑使用 myisam存储引擎 . 比如 bbs 中的 发帖表，回复表 .
INNODB存储引擎:
    对事务要求高，保存的数据都是重要数据，我们建议使用 INNODB,比如订单表，账号表 .
Memory 存储
    我们数据变化频繁，不需要入库，同时又频繁的查询和修改，我们考虑使用 memory, 速度极快 .

5.Java实现跨平台的原理? （Java程序运行的原理）
答: Java为我们提供了Java虚拟机(JVM),程序运行时,首先通过编译将后缀名为.java的源文件转换为后缀名为.class的字节码文件,然后Java虚拟机通过装载二进制文件、校验二进制码并解析，最后分发给不同的平台进行运行.

6.HashSet如何检查重复
当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，
HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。
如果两者相同，HashSet就不会让加入操作成功。
综上,先用hashcode进行比对,hashcode值相等再调用equals()方法比较是否真的相等.

hashCode（）与equals（）的相关规定：

    1.如果两个对象相等，则hashcode一定也是相同的
    2.两个对象相等,对两个equals方法返回true
    3.两个对象有相同的hashcode值，它们也不一定是相等的          [****1、2、3这三点很重要,先记下来,以后再去深究****]
    4.综上，equals方法被覆盖过，则hashCode方法也必须被覆盖
    5.hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。
    
7.==与equals的区别

    1.==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同
    2.==是指对内存地址进行比较 equals()是对字符串的内容进行比较
    3.==指引用是否相同 equals()指的是值是否相同    



    
